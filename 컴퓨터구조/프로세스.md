# 프로세스 :man_office_worker:

## 프로세스의 상태

### 생성

프로그램이 생성되어 프로세스가 생성되어 있는 상태

### 준비 상태 (Ready)

CPU의 할당을 기다린다. 특정 인터럽트가 발생하면 준비 상태로 전환.

병목 상태에 빠질 수 있다. ( 위험 )

- 정지 상태 -> 실행 가능

### 대기 상태 (Sleeping) == 실행 대기

- 커널이 시스템 호출을 처리하는 동안 **잠시** 기다리는 상태.

- 다른 프로세스가 I/O작업이 수행되는 동안 대기한다.
- 대기 상태 -> 준비 상태
- 대기 상태 -> 실행 가능

### 정지 상태

- 현재 상태를 유지한 상태에서 인터럽트를 건다 ? 다른 작업을 할 수 있게.
- ctrl+z 가 예시
- ctrl+c 는 프로세스 종료이다.
- 종료된 프로세스는 다시 살릴 수 없지만 정지된 프로세스는 다시 재개할 수 있다.
- 실행 -> 정지 상태 -> 실행 가능
- 실행 -> 정지 상태 -> quit

### 실행 가능

스케쥴러가 해당 작업을 허락하면 드디어 실행이 된다.

### 실행

- 실행 ->  대기 상태
- 실행 -> 정지 상태
- 실행 <--> 실행 가능
- 실행 -> 종료 대기
- 코드가 현재 CPU에서 실행되고 있는 상태로 유저모드와 커널모드를 호가며 수행된다.

### 종료 대기

종료하고 싶은 프로세스가 부모의 종료 허락을 기다리는 상태. 아직 메모리에 올라가 있다.

### 종료

부모 프로세스의 종료 해도된다는 신호를 받고 죽은 상태.

### 실행 중인 프로세스가 종료상태가 되기 까지

종료상태가 되고 싶은 프로세스는 부모 프로세스에게 자신이 죽어도 되는지 물어본다. 부모 프로세스는 이에 대한 응답 시그널을 자식 프로세스에게 준다. 시그널을 주기 전까지는 자식 프로세스는 메모리에 있지만 실행 될 수 없는 좀비 상태(  == 종료 대기 )가 된다. 마침내 종료 해도 좋다는 시그널을 받게되면 종료가 되며 메모리에서 내려온다.



![img](./img/img1.PNG)

<https://jundol.kr/106>

여기에 정지 상태, 종료 대기가 포함돼야 한다.



## 페이징

단편화를 해결하는 방법으로써 가상메모리를 최소 단위로 쪼개어 일정한 크기인 블럭을 페이지라 하고 실제 기억공간(RAM)은 페이지 크기와 같은 블럭으로 나누어 그를 프레임이라 한다. 그리하여 지금 사용할 메모리는  RAM의 프레임에, 사용 안할 메모리는 사용하기 전까지 페이지 공간에 있게 되고 해당 페이지가 필요하게 되면 swap하는 방식.

#### 페이지 테이블

- 운영체제 부팅시 메모리의 절대 물리주소의 특정 영역에 가상 주소 매핑을 위한 페이지 테이블을 생성한다.
- 프로세스의 페이지 정보를 저장하고 있으며 하나의 프로세스는 하나의 페이지 테이블을 가진다.
- 페이지 정보는 페이지 번호와 해당 페이지에 할당된 물리 메모리의 시작 주소를 가진다.